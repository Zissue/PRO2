// Per provar això conve implementar a més operacions de lectura i// escriptura de piles#include "stack.hh"int suma_pila_int_rec(stack<int>& p)/* Pre: p=P *//* Post: El resultat és la suma dels elements de P */{  int ret;  if (p.empty()) ret=0;  else{    int aux = p.top();    p.pop();    ret = suma_pila_int_rec(p);   // ret és la suma d'elements de P menys el primer element    ret+=aux;  }  return ret;}//En general, si el resultat es numeric o logic es pot fer tant iteratiu //com recursiuint suma_pila_int_it(stack<int> p)/* Pre: p=P *//* Post: El resultat és la suma dels elements de P */{  int ret=0;  while (not p.empty()) {    ret+=p.top();    p.pop();  }  return ret;}// amb piles d'estudiants bool cerca_pila_Estudiant_rec(stack<Estudiant>& p, int x)/* Pre: p=P *//* Post: El resultat ens diu si hi ha algun estudiant amb dni x a P */{  bool ret;  if(p.empty()) ret=false;  else if (p.top().consultar_DNI() == x) ret=true;  else {    p.pop();    ret = cerca_rec_pila_Estudiant(p,x);  }  return ret;}bool cerca_pila_Estudiant_it(stack<Estudiant> p, int x)/* Pre: p=P *//* Post: El resultat ens diu si hi ha algun estudiant amb dni x a P */{  bool ret = false;  while(not p.empty() and not ret){    if(p.top().consultar_DNI() == x) ret = true;    else p.pop();  }  return ret;}bool piles_iguals_rec(stack<int>& p1, stack<int>& p2)/* Pre: p1=P1, p2=P2 *//* Post: El resultat ens indica si P1 i P2 són iguals */{  bool ret;  if(p1.empty() and p2.empty()) ret = true;  else if (p1.empty() and not p2.empty()) ret = false;  else if (not p1.empty() and p2.empty()) ret = false;  else if (p1.top() != p2.top()) ret = false;  else {    p1.pop();    p2.pop();    ret = piles_iguals_rec(p1,p2);  }  return ret;}// si sabem que los size son iguals (s'hauria de preguntar abans de començar):bool piles_iguals_rec(stack<int>& p1, stack<int>& p2)/* Pre: p1=P1, p2=P2, p1.size() = p2.size() *//* Post: El resultat ens indica si P1 i P2 són iguals */{}// a la versio iterativa no cal comprovar els sizes forabool piles_iguals_it(stack<int> p1, stack<int> p2)/* Pre: p1=P1, p2=P2 *//* Post: El resultat ens indica si P1 i P2 són iguals */{}// Però si volem modificar una pila podriem tenir problemesvoid sumar_k_pila_acc_rec(stack<int>& p, int k)/* Pre: p=P *//* Post: Cada element de p és la suma de l'element de P   que ocupa la seva posició, més el valor k */{  if(not p.empty()){    int aux = p.top()+k;    p.pop();    sumar_k_pila_acc(p,k);    // en aquest punt, p conté els elements de P (+k) menys el cim    p.push(aux);  }}// Si ho fem iterativament generem la pila del revésvoid sumar_k_pila_acc_it(stack<int>& p, int k)/* Pre: p=P *//* Post: Cada element de p és la suma de l'element de P   que ocupa la seva posició, més el valor k */{  stack<int> aux;  while (not p.empty()){    aux.push(p.top()+k);    p.pop();  }  // aux es com ha de ser pero invertida  while(not aux.empty()){    p.push(aux.top());    aux.pop();  }}